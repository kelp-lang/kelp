//--------------
//  Kelp Prelude
//--------------
//  Traits

Show = &{
    show: [ . ] => String
}

Eq = &{
    eq: [. Eq] => Bool
    neq: [. Eq] => Bool
}

Ord::Eq = &{
    max: [. Ord] => Ord
    min: [. Ord] => Ord
}

Number::Ord = &{
    add: [. Number ] => Number
    subtract: [. Number ] => Number
    multiply: [. Number ] => Number
    modulo: [. Number ] => Number
}

Frac::Number = &{

}

Div::Number = &{
    divide: [ . Number ] => Frac
}

Boolean = &{
    and: [. Boolean ] => Boolean
    or: [. Boolean ] => Boolean
    not: [.] => Boolean
}

// TODO: Trait implementations for primitive types

// TODO: Vymyslet generické argumenty a tak haskell ukazuje hezky co by to mělo být
// TODO: Generické grupy, aka group s typem a neznámkou délokou, ne jenom tuply
// Třeba to _Typ jako generický typ maybe?
//Functor{_A} = {
//    map{_B}: [ . _A[] => _B] => Functor[_B]
//}

//Monad[_A] = {
//    bind[_B]: [ . [_A] => Monad[_B]] => Monad[_B]
//    unit[_B]: [_A] => Monad[_A]
//}

//--------------
// Operators


// Math Operators

+ = [lhs: Number rhs: Number] => Number (
    rhs -> lhs.add
)

- = [lhs: Number rhs: Number] => Number (
    rhs -> lhs.sub
)

* = [lhs: Number rhs: Number] => Number (
    rhs -> lhs.mul
)

/ = [lhs: Div rhs: Number] => Frac (
    rhs -> lhs.div
)

// Boolean Operators

^* = [lhs: Boolean rhs: Boolean] => Boolean (
    rhs -> lhs.and
)

^+ = [lhs: Boolean rhs: Boolean] => Boolean (
    rhs -> lhs.or
)

// Logic Operators

?= = [lhs: Eq rhs: Eq] => Bool ( 
    rhs -> lhs.eq
)

?! = [lhs: Eq rhs: Eq] => Bool (
    rhs -> lhs.neq
)

?> = [lhs: Ord rhs: Ord] => Bool (
    lhs ?! rhs ^* (rhs -> lhs.max ?= lhs)
)

?>= = [lhs: Ord rhs: Ord] => Bool (
    rhs -> lhs.max ?= lhs
)

?< = [lhs: Ord rhs: Ord] => Bool (
    lhs ?! rhs ^* (rhs -> lhs.min ?= lhs)
)

?<= = [lhs: Ord rhs: Ord] => Bool (
    rhs -> lhs.min ?= lhs
)

// Lists
// TODO: These sadly use generics


// Reduce: |}
// At: #