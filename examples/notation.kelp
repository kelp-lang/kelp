[
    "some/dir/if",
    "some/other/else"
] > use

fun = [lhs, rhs] (
    lhs + rhs
)

obj = {
    header = 1
    other_data = 0
}

trt = (
    ret: [Number, Number] -> Number
)

[*] = [lhs, rhs] (
    [lhs, rhs] > Number.mul
)

string = "Hello, こんにちわ!"
rune = 'に'
integer = 3
real = .3

array = [1, 2, 3, 3]
tuple = [a, 2, .03]

// This is a single line comment

import "Prelude.klp"

// functions are resolved during runtime
defun! add [lhs rhs] :Int (
    lhs + rhs
)

// macros are resolved during compilation as opposed to functions
// macros don't allow named arguments, all arguments are positional
// macros don't need type parameters, since they are expanded before
// the type is checked
defmacro! eval_macro [not_evaluated] (
    eval not_evaluated
)

defobj! obj {
    #property 0 #property2 2
}

def! string "Hello, こにちは!"
def! number 3
def! list [1 2 "lol"]
def! array <[1 3 4 5]> //TODO: This is only a potential syntax
def! tuple {#x 0 #y 3}

add 4 (add 5 2) // results in 13
add 4 < add 5 2 // TODO: results in 13
add 4 add 5 2 // error, cannot add function to a number
add 4 'add 5 2 // error, cannot add function to a number
add 4 < 3 * 3 // TODO: result is 13
add 4 (3 * 3) // result is 13
add 4 3 > * 3 // TODO: result is 20